---
title: Getting Started Deploying Ruby on Rails Apps
---

<%=vars.GSG_intro_sentence%>

This guide is intended to walk you through deploying a Ruby on Rails (RoR) app to <%=vars.product_full%>. If at any time you experience a problem following the steps below, check the <%=vars.known_issues%> topic, or refer to the [Troubleshooting Application Deployment and Health](./../../devguide/deploy-apps/troubleshoot-app-health.html) topic for more tips.


## <a id='deploy-yourapp'></a>Deploy a RoR Application ##

This section describes how to deploy a RoR application to <%=vars.product_short%>, and uses output from a sample app to show specific steps of the deployment process. 

<p class="tip"><strong>Sample App Step</strong><br />If you want to go through this tutorial using the sample app, run <code>git clone https://github.com/cloudfoundry-samples/rails_sample_app</code> to clone the <code>rails_sample_app</code> from GitHub, and follow the instructions in the Sample App Step boxes.</p>
	
### Prerequisites ###

* A Rails 4.x app that runs locally on your workstation
* [Bundler](http://bundler.io) configured on your workstation
* Intermediate to advanced RoR knowledge
* The [cf Command Line Interface (CLI)](../../devguide/installcf/install-go-cli.html)
- (**Optional**) Robust production web server for Ruby and RoR apps, such as Unicorn

### Step 1: Add the rails_12factor Gem to Your Gemfile ###

1. Add `gem 'rails_12factor', group: :production` to your Gemfile.

    <p class="note"><strong>Note</strong>:  This gem includes the <code>rails&#095;serve&#095;static&#095;assets</code> gem that enables your Rails app to run in production with the static assets serving functionality. The <code>rails&#095;serve&#095;static&#095;assets</code> gem does this by automatically modifying the <code>config.serve&#095;static&#095;assets</code> configuration parameter from <code>false</code> to <code>true</code>. Do not change the value for this option. For more information, refer to the <a href="https://github.com/heroku/rails_12factor">Rails_12factor GitHub README</a>.</p>

1. Run `bundle install` to update your Gemfile.

<p class="tip"><strong>Sample App Step</strong><br />You can skip this step. This gem is already included in the <code>rails_sample_app</code> Gemfile.</p>

### Step 2: (Optional) Configure Automatically Invoked Rake Tasks for Deployed Applications ###

<%=vars.product_short%> does not provide a way to run a Rake task on a deployed application. For <%=vars.product_short%> to automatically invoke a Rake task while an app is deployed, you must include the Rake task in your application and also configure the application start command with the `command` attribute in the application manifest, `manifest.yml`.
The following is an example of how to invoke a Rake database migration task at application startup.

1. Create a file with the Rake task name and the extension `.rake`, and store it in the `lib/tasks` directory of your application.

1. Add the following code to your rake file:

    <pre class="code">
    namespace :cf do
        desc "Only run on the first application instance"
        task :on_first_instance do
            instance_index = JSON.parse(ENV["VCAP_APPLICATION"])["instance_index"] rescue nil
        exit(0) unless instance_index == 0
        end
    end
    </pre>

    This Rake task limits an idempotent command to the first instance of a deployed application.

1. Add the task to the `manifest.yml` file with the `command` attribute, referencing the idempotent command `rake db:migrate` chained with a start command.

    <pre class="code">
applications:
 &#8208; name: my-rails-app
 command: bundle exec rake cf:on_first_instance db:migrate && rails s -p $PORT
    </pre>

<p class="tip"><strong>Sample App Step</strong><br />You can skip this step. The <code>rails_sample_app</code> has no Rake tasks.</p>

### Step 3: Create and Bind a Service Instance for a RoR Application ###

This section describes using the CLI to configure a PostgreSQL managed service instance for your app. <%=vars.dev_console_1%>

<%=vars.product_short%> supports two types of service instances:

* Managed services integrate with <%=vars.product_short%> through service brokers that offer services and plans and manage the service calls between <%=vars.product_short%> and a service provider.
* User-provided service instances enable you to connect your application to pre-provisioned external service instances.

For more information on creating and using service instances, refer to the [Services Overview](./../../devguide/services/index.html) topic.

#### Create a Service Instance ####

Run `cf marketplace` to view managed and user-provided services and plans available to you.

The example shows three of the available managed database-as-a-service providers and their offered plans: `cleardb` MySQL, `elephantsql` PostgreSQL as a Service, and `mongolab` MongoDB-as-a-Service.

<pre class="terminal">
$  cf marketplace
Getting services from marketplace in org Cloud-Apps / space development as clouduser@example.com...
OK

service          plans 	description
...
cleardb          spark, boost, amp, shock  	Highly available MySQL for your Apps
...
elephantsql      turtle, panda, hippo, elephant   PostgreSQL as a Service
...
mongolab         sandbox   	Fully-managed MongoDB-as-a-Service
...
</pre>

Run `cf create-service [SERVICE] [PLAN] [SERVICE_INSTANCE]` to create a service instance for your app. Choose a SERVICE and PLAN from the list, and provide a unique name for the SERVICE_INSTANCE.

<p class="tip"><strong>Sample App Step</strong><br />Run <code>cf create-service elephantsql turtle rails-postgres</code>. This creates a service instance named <code>rails-postgres</code> that uses the <code>elephantsql</code> service and the <code>turtle</code> plan, as the example below shows.

<pre class="terminal">
$   cf create-service elephantsql turtle rails-postgres
Creating service rails-postgres in org Cloud-Apps / space development as clouduser@example.com....
OK
</pre>
</p>

#### Bind a Service Instance ####

When you bind an app to a service instance, <%=vars.product_short%> writes information about the service instance to the VCAP_SERVICES app environment variable. The app can use this information to integrate with the service instance.

Most services support bindable service instances. Refer to your service provider's documentation to confirm if they support this functionality.

You can bind a service to an application with the command `cf bind-service APPLICATION SERVICE_INSTANCE`.

For example, to bind the `rails-postgres` service that we created in the previous example:

<pre class="terminal">
$ cf bind-service my-rails-app rails-postgres
</pre>

Alternately, you can configure the deployment manifest file by adding a `services` block to the `applications` block and specifying the service instance. For more information and an example on service binding using a manifest, see the next step.

<%=vars.dev_console_5%>

<p class="tip"><strong>Sample App Step</strong><br />You can skip this step. The manifest for the sample app contains a <code>services</code> subblock in the <code>applications</code>block. This binds the <code>rails-postgres</code> service instance you created in the previous step.</p>

### Step 4: Configure the Manifest File  ###

You can specify app deployment options in a manifest that the `cf push` command uses. For more information about application manifests and supported attributes, refer to the [Deploying with Application Manifests](./../../devguide/deploy-apps/manifest.html) topic.

<p class="tip"><strong>Sample App Step</strong><br />You can skip this step. You can open the <code>manifest.yml</code> file in a text editor to view the bound service instance information. Locate the file in the app root directory and search for the <code>services</code> subblock in the <code>applications</code> block, as the example shows.

<pre class="code">
---
applications:
...
  services:
    - rails-postgres
</pre>

</p>


### Step 5: Log in and Target the API Endpoint ###

Run `cf login -a [API_ENDPOINT]`, enter your login credentials, and select a space and org. The API endpoint is <%=vars.api_endpoint%>.

  <%=vars.gen_GSG%>

  <p class="tip"><strong>Sample App Step</strong><br />You must do this step to run the sample app.</p>


### Step 6: (Optional) Configure a Production Server  ###

<%=vars.product_short%> uses the default standard Ruby web server library WEBrick for Ruby and RoR apps. However, <%=vars.product_short%> can support a more robust production web server, such as Phusion Passenger, Puma, Thin, or Unicorn.

To instruct <%=vars.product_short%> to use a web server other than WEBrick, you configure a text file called a _Procfile_. A Procfile enables you to declare required runtime processes, called _process_ _types_, for your web app. Process managers in a server use the process types to run and manage the workload.

When you deploy, <%=vars.product_short%> determines if a Procfile exists and uses the Procfile to configure your app with the specified production web server settings.

In a Procfile, you declare one process type per line and use the following syntax, as shown in the example below:

* `PROCESS_TYPE` is the command name in the format of an alphanumeric string. Specifically for RoR web apps, you can declare `web` and `worker` process types.
* `COMMAND` is the command line to launch the process.

Example process type syntax:
    <pre class="code">
    PROCESS_TYPE: COMMAND
</pre>

To set a different production web server for your app:

1. Add the gem for the web server to your Gemfile. 

1. In the `config` directory of your app, create a new configuration file or modify an existing file.

    Refer to your web server documentation for how to configure this file.

    Example Puma config file:
    <pre class="code">
    &#35; config/puma.rb
    threads 8,32
    workers 3

    on\_worker\_boot do
      # things workers do
    end
</pre>

1. In the root directory of your app, create a Procfile and add a command line for a `web` process type that points to your web server. 

    The example below shows a command that starts a Puma web server and specifies the app runtime environment, TCP port, and paths to the server state information and configuration files.
    Refer to your web server documentation for how to configure the specific command for a process type.

    Example Procfile:
    <pre class="code">
    web: bundle exec puma -e $RAILS_ENV -p 1234 -S ~/puma -C config/puma.rb
    </pre>
	
<p class="tip"><strong>Sample App Step</strong><br />You can skip this step. The <code>rails_sample_app</code> does not require a production server.</p>	

### Step 7: Deploy an App ###

<p class="note"><strong>Note</strong>: You must use the cf CLI to deploy apps.</p>

From the root directory of your application, run `cf push [APP-NAME]` to deploy your application. 

`cf push [APP-NAME]` creates a URL route to your application in the form HOST.DOMAIN, where HOST is your [APP-NAME] and DOMAIN is specified by your administrator. Your DOMAIN is`<%=vars.app_domain%>`. For example: `cf push my-app` creates the URL `my-app.<%=vars.app_domain%>`.

The URL for your app must be unique from other apps that <%=vars.product_short%> hosts or the push will fail. Use the following options to help create a unique URL:

* `-n` to assign a different HOST name for the app.
* `--random-route` to create a URL that includes the app name and random words.
* Run `cf help push` to view other options for this command.

If you want to view log activity while the app deploys, launch a new terminal window and run `cf logs [APP-NAME]`.

Once your app deploys, browse to your app URL. Search for the `urls` field in the `App started` block in the output of the `cf push` command. Use the URL to access your app online.

<p class="tip"><strong>Sample App Step</strong><br />
Run <code>cf push rails_sample_app -n [HOST_NAME]</code>.
<br /><br />
Example: <code>cf push rails_sample_app -n jc0825-rails</code>
<br /><br />
The example below shows the terminal output of deploying the <code>rails_sample_app</code>. <code>cf push</code> uses the instructions in the manifest file to create the app, create and bind the route, and upload the app. It then binds the app to the <code>rails-postgres</code> service and follows the instructions in the manifest to start one instance of the app with 256M. After the app starts, the output displays the health and status of the app.
</p>

<pre class="terminal">

	$ cf push rails_sample_app -n jmt2014-rails
	Using manifest file /Users/pivotal/workspace/rails_sample_app/manifest.yml

	Updating app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	Using route jmt2014-rails.<%=vars.app_domain%>
	Uploading rails_sample_app...
	Uploading app files from: /Users/pivotal/workspace/rails_sample_app
	Uploading 445.7K, 217 files
	OK
	Binding service rails-postgres to app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	Starting app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	...

	0 of 1 instances running, 1 starting
	1 of 1 instances running

	App started

	Showing health and status for app rails_sample_app in org Cloud-Apps / space development as clouduser@example.com...
	OK

	requested state: started
	instances: 1/1
	usage: 256M x 1 instances
	urls: jmt2014-rails.<%=vars.app_domain%>

	     state     since                    cpu    memory          disk
	#0   running   2014-08-25 03:32:10 PM   0.0%   68.4M of 256M   73.4M of 1G

</pre>

Let’s access your app online using its URL. In the terminal output, the `urls` field of the `App started` block contains the app URL. This is the `HOST_NAME` you specified with the `-n` flag plus the domain `<%=vars.app_domain%>`. The image shows the resulting webpage:

<%= image_tag("../images/RoR_sample_webpage.png") %>


### Step 8: Test a Deployed App ###

You’ve deployed an app to <%=vars.product_short%>! 

You can now use the `cf` <%=vars.dev_console_2%> to review information and administer your app and your <%=vars.product_short%> account. For example, you could edit the `manifest.yml` to increase the number of app instances from 1 to 3, and redeploy the app with a new app name and host name.

See the [Manage Your Application with the cf CLI](#cli-manage) section for more information. <%=vars.dev_console_4%>

## <a id='cli-manage'></a>Manage Your Application with the cf CLI ##

Run `cf help` to view a complete list of commands, grouped by task categories, and run `cf help [COMMAND]` for detailed information about a specific command. For more information about using the `cf` CLI, refer to the cf Command Line Interface (CLI) topics, especially the <%=vars.cli_v6%> topic.

<p class="note"><strong>Note</strong>: You cannot perform certain tasks in the <%=vars.dev_console_2%> because these are commands that only a <%=vars.product_short%> administrator can run. If you are not a <%=vars.product_short%> administrator, the following message displays for these types of commands:

<code>error code: 10003, message: You are not authorized to perform the requested action</code>

<%=vars.dev_console_note%>
</p>

## <a id='troubleshoot'></a>Troubleshooting ##
If your application fails to start, verify that the application starts in your local environment. Refer to the [Troubleshooting Application Deployment and Health](./../../devguide/deploy-apps/troubleshoot-app-health.html) topic to learn more about troubleshooting.

### App Deploy Fails ###
Even when the deploy fails, the app might exist on <%=vars.product_short%>. Run `cf apps` to review the apps in the currently targeted org and space. You might be able to correct the issue using the <%=vars.dev_console_2%>, or you might have to delete the app and redeploy.

Common reasons deploying an app fails include:

* You did not successfully create and bind a needed service instance to the app, such as a PostgreSQL or MongoDB service instance. Refer to Step 3: Create and Bind a Service Instance for a RoR Application.
* You did not successfully create a unique URL for the app. Refer to the troubleshooting tip App Requires Unique URL.

### App Requires Unique URL ###
<%=vars.product_short%> requires that each app that you deploy have a unique URL. Otherwise, the new app URL collides with an existing app URL and <%=vars.product_short%> cannot successfully deploy the app. You can fix this issue by running `cf push` with either of the following flags to create a unique URL:

* `-n` to assign a different HOST name for the app.
* `--random-route` to create a URL that includes the app name and random words. Using this option might create a long URL, depending on the number of words that the app name includes.






