---
title: Understanding Buildpacks
owner: Buildpacks
---

<strong><%= modified_date %></strong>

This topic describes how buildpacks work in Cloud Foundry.

## <a id='buildpack-scripts'></a>Buildpack Scripts ##

A buildpack repository contains the folllowing four main scripts, situated in a folder named `bin`:

* `bin/detect` determines whether or not to apply the buildpack to an app
* `bin/supply` supplies dependencies for an app
* `bin/finalize` prepares the app for launch
* `bin/release` provides feedback metadata to Cloud Foundry indicating how the app should be executed

The `bin/supply` and `bin/finalize` scripts replace the deprecated `bin/compile` script. Older buildpacks may still use `bin/compile`, but they do not support applying multiple buildpacks to a single application.

### <a id='detect-script'></a>bin/detect ###

The `detect` script determines whether or not to apply the buildpack to an app. The script is called with one argument, the `build` directory for the app. The `build` directory contains the app files uploaded when a user performs a `cf push`. 

The `detect` script returns an exit code of `0` if the buildpack is compatible with the app. In the case of system buildpacks, the script also prints the buildpack name, version, and other helpful information to `STDOUT`. 

The following is an example `detect` script written in Ruby that checks for a Ruby app based on the existence of a `Gemfile`:

~~~ruby
#!/usr/bin/env ruby

gemfile_path = File.join ARGV[0], "Gemfile"

if File.exist?(gemfile_path)
  puts "Ruby"
  exit 0
else
  exit 1
end
~~~

Optionally, the buildpack detect script can output additional details decided by the buildpack developer. These additional details include buildpack versioning information and a detailed list of configured frameworks and their associated versions. 

The following is an example of the detailed information returned by the Java buildpack:

~~~
java-buildpack=v3.0-https://github.com/cloudfoundry/java-buildpack.git#3bd15e1 open-jdk-jre=1.8.0_45 spring-auto-reconfiguration=1.7.0_RELEASE tomcat-access-logging-support=2.4.0_RELEASE tomcat-instance=8.0.21 tomcat-lifecycle-support=2.4.0_RELEASE ...
~~~

For more information, see the [Buildpack Detection](#buildpack-detection) section below.

### <a id='supply-script'></a>bin/supply ###

The `supply` script supplies dependencies for the app, and runs for all buildpacks.

### <a id='finalize-script'></a>bin/finalize ###

The `finalize` script prepares the app for launch, and only runs for the last buildpack.

### <a id='release-script'></a>bin/release ###

The `release` script provides feedback metadata to Cloud Foundry indicating how the app should be executed. The script is run with one argument, the `build` directory. The script must generate a YAML file in the following format:

~~~yaml
default_process_types:
  web: start_command.filetype
~~~

`default_process_types` indicates the type of app being run and the command used to start it. 
This start command is used if a start command is not specified in the `cf push` or in a Procfile.

At this time, only `web` type of apps are supported.

<p class="note"><strong>Note</strong>: To define environment variables for your buildpack, add a bash script to the <code>.profile.d</code> directory in the root folder of your app.</p>

The following example shows what a `release` script for a Rack app might return:

~~~ruby
default_process_types:
  web: bundle exec rackup config.ru -p $PORT
~~~

<p class="note"><strong>Note</strong>: The <code>web</code> command runs as <code>bash -c COMMAND</code> when Cloud Foundry starts your app. Refer to <a href="../devguide/deploy-apps/manifest.html#start-commands">the command attribute</a> section for more information about custom start commands. </p>

## <a id='droplet-filesystem'></a> Droplet Filesystem ##

The buildpack staging process extracts the droplet into the `/home/vcap` directory inside the instance container, and creates the following filesystem tree:

```
app/ 
logs/
tmp/
staging_info.yml
```
The `app` directory contains `BUILD_DIR` contents, and `staging_info.yml` contains the staging metadata saved in the droplet.

### <a id='compile-script'></a>bin/compile (Deprecated)###

The `compile` script builds a droplet by packaging the app dependencies, assuring that the app has all the necessary components needed to run.

The script is run with two arguments: the `build` directory for the app and the `cache` directory, which is a location the buildpack can use to store assets during the build process. During the execution of the `compile` script, all output sent to `STDOUT` is relayed through the cf CLI to the user.

The following is an example of a simple `compile` script:

~~~ruby
#!/usr/bin/env ruby

#sync output

$stdout.sync = true

build_path = ARGV[0]
cache_path = ARGV[1]

install_ruby

private

def install_ruby
  puts "Installing Ruby"

  # !!! build tasks go here !!!
  # download ruby 
  # install ruby
end
~~~


##<a id='buildpack-detection'></a> Buildpack Detection

When you push an app, Cloud Foundry uses a detection process to determine which buildpack to use. 
For general information about this process, see [How Applications Are Staged](../concepts/how-applications-are-staged.html#stage-buildpack). 

During staging, each buildpack has a position in a priority list. You can retrieve this position by running `cf buildpack`.

Cloud Foundry checks if the buildpack in position 1 is a compatible buildpack. If the position 1 buildpack is not compatible, Cloud Foundry moves on to the buildpack in position 2. Cloud Foundry continues this process until the correct buildpack is found. 

If no buildpack is compatible, the `cf push` command fails with the following error:

<pre class="terminal">
None of the buildpacks detected a compatible application
Exit status 222
Staging failed: Exited with status 222

FAILED
NoAppDetectedError
</pre>

For a more detailed account of how Cloud Foundry interacts with the buildpack, see the [Sequence of Interactions](#interactions) section below.

##<a id='interactions'></a> Sequence of Interactions 

This section provides a detailed account of the sequence of interactions between the Cloud Foundry platform and the buildpack. The sequence of interactions differs depending on whether the platform [skips](#no-detection) or [performs](#detection) buildpack detection.

###<a id='no-detection'></a> No Buildpack Detection

The platform skips buildpack detection if the developer specifies one or more buildpacks in the application manifest or with the cf CLI using the `cf push APP-NAME -b BUILDPACK-NAME` command.

If the platform skips detection, it performs the following interactions:

1. For each buildpack except the last buildpack, the platform does the following:
	1. Runs `/bin/supply` on the `app`, `cache`, and `deps` directory
	1. Accepts any modification of the `deps` directory
	1. Accepts any modification of the `cache` directory
	1. May disallow modification to any other directory
1. For the last buildpack, the platform does the following:
	1. If `/bin/finalize` is present:
		1. Creates the `deps` directory if not present
		1. If `/bin/supply` is present, runs `/bin/supply` on the `app`, `cache`, and `deps` directory 
		1. Accepts any modification of the `deps` directory
		1. May disallow modification of the `app` directory
		1. Runs `/bin/finalize` on the `app`, `cache`, and `deps` directory 
		1. Accepts any modification of the `app` directory
	1. If `/bin/finalize` is not present:
		1. Runs `/bin/compile` on the `app` and `cache` directory 
		1. Accepts any modification of the `app` directory
	1. Runs `/bin/release` to determine staging information

At the conclusion of this process, the `deps` directory is included at the root of the droplet, adjacent to the `app` directory. 

###<a id='detection'></a> Buildpack Detection

The platform performs buildpack detection if the developer does not specify one or more buildpacks in the application manifest or with the cf CLI using the `cf push APP-NAME -b BUILDPACK-NAME` command.

<p class="note"><strong>Note</strong>: The platform detects only one buildpack to use with the application.</p>

If the platform performs detection, it performs the following interactions:

1. Runs `/bin/detect` for each buildpack
1. Selects the first buildpack with a `/bin/detect` script that returns a zero exit status
1. Creates `/tmp/cache/primary/` if not present
1. If `/bin/finalize` is present:
	1. Creates the `deps` directory if not present
	1. If `/bin/supply` is present, runs `/bin/supply` on the `app`, `cache`, and `deps` directory 
	1. Accepts any modification of the `deps` directory
	1. May disallow modification of the `app` directory
	1. Runs `/bin/finalize` on the `app`, `cache`, and `deps` directory 
	1. Accepts any modification of the `app` directory
1. If `/bin/finalize` is not present:
	1. Runs `/bin/compile` on the `app` and `cache` directory 
	1. Accepts any modification of the `app` directory
1. Runs `/bin/release` to determine staging information

At the conclusion of this process, the `deps` directory is included at the root of the droplet, adjacent to the `app` directory. 
